import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.channels.ReceiveChannel
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking

// = = = = = = Key points = = = = = =
//  Channels provide the functionality for sending and receiving streams of values.

//  Channel implements both SendChannel and ReceiveChannel interfaces; therefore, it could be used for sending and receiving streams of values.

//  A Channel can be closed. When that happens, you can’t send or receive an element from it.

//  The send() method either adds the value to a channel or suspends the coroutine until there is space in the channel.

//  The receive() method returns a value from a channel if it is available, or it suspends the coroutine until some value is available otherwise.

//  The offer() method can be used as an alternative to send(). Unlike the send() method, offer() doesn’t suspend the coroutine, it returns false instead.
// It returns true in case of a successful operation.

//  poll() similarly to offer() doesn’t suspend the running, but returns null if a channel is empty.

//  Java BlockingQueue has a similar to Kotlin Channel behavior, the main difference is that the current thread gets
// blocked if the operation of inserting or retrieving is unavailable at the moment.
//=====================================================================================================================
interface Item {
  val name: String
  val color: String
}


// @Predicate is any function with a parameter of generic type E which can return either true or false.
// @Rule is a name for a Pair of a Channel and a Predicate.
// @Pair represents a generic pair of two values.
//The idea is to allow a coroutine to send a value to a specific channel only if its predicate returns true if evaluated for the value itself.
typealias Predicate<E> = (E) -> Boolean
typealias Rule<E> = Pair<Channel<E>, Predicate<E>>

class Demultiplexer<E>(vararg val rules: Rule<E>) {
  suspend fun consume(recv: ReceiveChannel<E>) {
    for (item in recv) {
      //1
      for (rule in rules) {
        //2
        if (rule.second(item)) {
          rule.first.send(item)
        }
      }
    }
    //4
    closeAll()
  }

  private fun closeAll() {
    rules.forEach { it.first.close() }
  }
}

@ExperimentalCoroutinesApi
fun main() {

  data class Fruit(override val name: String, override val color: String) : Item
  data class Vegetable(override val name: String, override val color: String) : Item

  // ------------ Helper Methods ------------
  fun isFruit(item: Item) = item is Fruit

  fun isVegetable(item: Item) = item is Vegetable

  // 1 Create a produceItems function for producing a fruit or vegetable.
  fun produceItems(): ArrayList<Item> {
    val itemsArray = ArrayList<Item>()
    itemsArray.add(Fruit("Apple", "Red"))
    itemsArray.add(Vegetable("Zucchini", "Green"))
    itemsArray.add(Fruit("Grapes", "Green"))
    itemsArray.add(Vegetable("Radishes", "Red"))
    itemsArray.add(Fruit("Banana", "Yellow"))
    itemsArray.add(Fruit("Cherries", "Red"))
    itemsArray.add(Vegetable("Broccoli", "Green"))
    itemsArray.add(Fruit("Strawberry", "Red"))
    itemsArray.add(Vegetable("Red bell pepper", "Red"))
    return itemsArray
  }

  runBlocking {
    //2 Create a channel for Item.
    val kotlinChannel = Channel<Item>()
    // 3 Create the fruitsChannel channel for items that are fruits and a vegetablesChannel channel for items that are vegetables.
    val fruitsChannel = Channel<Item>()
    val vegetablesChannel = Channel<Item>()

    // 4 Launch a coroutine for sending all items generated by the produceItems function.
    launch {
      produceItems().forEach {
        kotlinChannel.send(it)
      }
      // 5 When completed, close the channel.
      kotlinChannel.close()
    }

    //6 Create a Demultiplexer instance, which maps items that are fruit to the fruitsChannel and items that are vegetables to the vegetablesChannel
    //The Demultiplexer has a consume method, which is suspending, and it needs a coroutine to launch.

    val typeDemultiplexer = Demultiplexer(
        fruitsChannel to { item: Item -> isFruit(item) },
        vegetablesChannel to { item: Item -> isVegetable(item) }
    )
    // 7 Separate fruit and Vegetable Channel
    launch {
      typeDemultiplexer.consume(kotlinChannel)
    }
    // 8 Consume Fruits channel
    launch {
      for (item in fruitsChannel) {
        // Consume fruitsChannel
        delay(1000)
        println("${item.name} is a fruit")
      }
    }
    // 9 Consume Vegetable channel
    launch {
      for (item in vegetablesChannel) {
        // Consume vegetablesChannel
        delay(1000)
        println("${item.name}  is a vegetable")
      }
    }
  }

}









